# 语音包参考https://learn.microsoft.com/zh-cn/azure/ai-services/speech-service/language-support?tabs=tts

whisper_voice_mapping = {
    'af': 'af-ZA-AdriNeural3',
    'am': 'am-ET-MekdesNeural3',
    'ar': 'ar-SA-ZariyahNeural',
    'as': 'as-IN-YashicaNeural3',
    'az': 'az-AZ-BanuNeural3',
    'bg': 'bg-BG-KalinaNeural',
    'bn': 'bn-IN-TanishaaNeural3',
    'bs': 'bs-BA-VesnaNeural3',
    'ca': 'ca-ES-JoanaNeural',
    'cs': 'cs-CZ-VlastaNeural',
    'cy': 'cy-GB-NiaNeural3',
    'da': 'da-DK-ChristelNeural',
    'de': 'de-DE-KatjaNeural',
    'el': 'el-GR-AthinaNeural',
    'en': 'en-US-JennyNeural',
    'es': 'es-ES-ElviraNeural',
    'et': 'et-EE-AnuNeural3',
    'eu': 'eu-ES-AinhoaNeural3',
    'fa': 'fa-IR-DilaraNeural3',
    'fi': 'fi-FI-SelmaNeural',
    'fr': 'fr-FR-DeniseNeural',
    'gl': 'gl-ES-SabelaNeural3',
    'gu': 'gu-IN-DhwaniNeural',
    'he': 'he-IL-HilaNeural',
    'hi': 'hi-IN-AnanyaNeural',
    'hr': 'hr-HR-GabrijelaNeural',
    'hu': 'hu-HU-NoemiNeural',
    'hy': 'hy-AM-AnahitNeural3',
    'id': 'id-ID-GadisNeural',
    'is': 'is-IS-GudrunNeural3',
    'it': 'it-IT-ElsaNeural',
    'ja': 'ja-JP-NanamiNeural',
    'ka': 'ka-GE-EkaNeural3',
    'kn': 'kn-IN-SapnaNeural3',
    'ko': 'ko-KR-SunHiNeural',
    'lt': 'lt-LT-OnaNeural3',
    'lv': 'lv-LV-EveritaNeural3',
    'mk': 'mk-MK-MarijaNeural3',
    'ml': 'ml-IN-SobhanaNeural3',
    'mr': 'mr-IN-AarohiNeural',
    'ms': 'ms-MY-YasminNeural',
    'mt': 'mt-MT-GraceNeural3',
    'my': 'my-MM-NilarNeural3',
    'ne': 'ne-NP-HemkalaNeural3',
    'nl': 'nl-NL-FennaNeural',
    'pa': 'pa-IN-VaaniNeural3',
    'pl': 'pl-PL-AgnieszkaNeural',
    'ps': 'ps-AF-LatifaNeural3',
    'pt': 'pt-PT-RaquelNeural',
    'ro': 'ro-RO-AlinaNeural',
    'ru': 'ru-RU-SvetlanaNeural',
    'si': 'si-LK-ThiliniNeural3',
    'sk': 'sk-SK-ViktoriaNeural',
    'sl': 'sl-SI-PetraNeural',
    'so': 'so-SO-UbaxNeural3',
    'sq': 'sq-AL-AnilaNeural3',
    'sr': 'sr-Latn-RS-SophieNeural3',
    'su': 'su-ID-TutiNeural3',
    'sv': 'sv-SE-SofieNeural',
    'sw': 'sw-KE-ZuriNeural3',
    'ta': 'ta-IN-PallaviNeural',
    'te': 'te-IN-ShrutiNeural',
    'th': 'th-TH-PremwadeeNeural',
    'tr': 'tr-TR-EmelNeural',
    'uk': 'uk-UA-PolinaNeural',
    'ur': 'ur-PK-UzmaNeural',
    'vi': 'vi-VN-HoaiMyNeural',
    'yue': 'yue-CN-XiaoMinNeural3',
    'zh': 'zh-CN-XiaoxiaoNeural',
    'zt': 'zh-TW-HsiaoChenNeural'
}

libretranslate_voice_mapping = {
    'ar': 'ar-SA-ZariyahNeural',
    'az': 'az-AZ-BanuNeural3',
    'bg': 'bg-BG-KalinaNeural',
    'bn': 'bn-IN-TanishaaNeural3',
    'ca': 'ca-ES-JoanaNeural',
    'cs': 'cs-CZ-VlastaNeural',
    'da': 'da-DK-ChristelNeural',
    'de': 'de-DE-KatjaNeural',
    'el': 'el-GR-AthinaNeural',
    'en': 'en-US-JennyNeural',
    'es': 'es-ES-ElviraNeural',
    'et': 'et-EE-AnuNeural3',
    'eu': 'eu-ES-AinhoaNeural3',
    'fa': 'fa-IR-DilaraNeural3',
    'fi': 'fi-FI-SelmaNeural',
    'fr': 'fr-FR-DeniseNeural',
    'ga': 'ga-IE-OrlaNeural3',
    'gl': 'gl-ES-SabelaNeural3',
    'he': 'he-IL-HilaNeural',
    'hi': 'hi-IN-AnanyaNeural',
    'hu': 'hu-HU-NoemiNeural',
    'id': 'id-ID-GadisNeural',
    'it': 'it-IT-ElsaNeural',
    'ja': 'ja-JP-NanamiNeural',
    'ko': 'ko-KR-SunHiNeural',
    'lt': 'lt-LT-OnaNeural3',
    'lv': 'lv-LV-EveritaNeural3',
    'ms': 'ms-MY-YasminNeural',
    'nl': 'nl-NL-FennaNeural',
    'pl': 'pl-PL-AgnieszkaNeural',
    'pt': 'pt-PT-RaquelNeural',
    'ro': 'ro-RO-AlinaNeural',
    'ru': 'ru-RU-SvetlanaNeural',
    'sk': 'sk-SK-ViktoriaNeural',
    'sl': 'sl-SI-PetraNeural',
    'sq': 'sq-AL-AnilaNeural3',
    'sr': 'sr-Latn-RS-SophieNeural3',
    'sv': 'sv-SE-SofieNeural',
    'th': 'th-TH-PremwadeeNeural',
    'tl': 'fil-PH-BlessicaNeural3',
    'tr': 'tr-TR-EmelNeural',
    'uk': 'uk-UA-PolinaNeural',
    'ur': 'ur-PK-UzmaNeural',
    'vi': 'vi-VN-HoaiMyNeural',
    'zh': 'zh-CN-XiaoxiaoNeural',
    'zt': 'yue-CN-YunSongNeural',
    'wuu': 'zh-CN-YunzeNeural'
}

import requests
import pyaudio
import miniaudio
class TTSHandler:
    def __init__(self,logger,params,mode,header,outputList,ttsVoice):
        self.baseurl=params["config"].get('baseurl')
        self.sourceType='whisper'if mode!='mic' else'libre'
        self.header=header
        self.logger=logger
        self.ttsVoice=ttsVoice
        if params["config"].get("TTSOutputName")== "" or params["config"].get("TTSOutputName") is None or params["config"].get("TTSOutputName")== "default":
            logger.put({"text":"使用系统默认输出","level":"info"})
            self.deviceindex=None
        else:
            try:
                self.deviceindex=outputList.index(params["config"].get("TTSOutputName"))
            except ValueError:
                logger.put({"text":"无法找到指定输出，使用系统默认麦克风","level":"info"})
                self.deviceindex=None
        self.p=pyaudio.PyAudio()            # 初始化 PyAudio 实例
    # def __delattr__(self, name):
    #     self.p.terminate()
    def __del__(self): # Use __del__ for cleanup
        if hasattr(self, 'p') and self.p:
            self.p.terminate()
            self.logger.put({"text": "PyAudio instance terminated.", "level": "debug"})
    def tts_audio(self, text, language='zh'):
        # TODO 增加按键切换开关
        self.logger.put({"text": f"{self.baseurl}/func/tts", "level": "debug"})
        audio_stream = None
        mp3_buffer = bytearray()
        
        # Track the total number of PCM samples (individual float/int values, not frames)
        # that have been decoded from the mp3_buffer and sent to PyAudio.
        total_pcm_samples_forwarded = 0
        
        # Assuming 16-bit signed PCM, so 2 bytes per sample.
        # This will be confirmed once we decode the first chunk.
        bytes_per_sample = 2 # Default, will be updated
        try:
            response = requests.post(
                self.baseurl + '/func/tts',
                json={
                    "input": text,
                    "voice": self.ttsVoice['libretranslate_voice_mapping'][language] if self.sourceType == 'libre' else self.ttsVoice['whisper_voice_mapping'][language],
                    "speed": 1.2
                },
                headers=self.header,
                stream=True,
                timeout=30 # Add a timeout for the request
            )

            # 先检查响应状态码
            if response.status_code != 200:
                if response.status_code == 430:
                    res = response.json()
                    self.logger.put({"text": f"TTS请求过于频繁,触发规则{res.get('limit')}", "level": "warning"})
                else:
                    self.logger.put({"text": f"TTS数据接收异常:{response.text}", "level": "warning"})
                return
            self.logger.put({"text": f"TTS文本生成: {text}", "level": "debug"})



            # 逐块接收并解码 MP3 数据
            for chunk in response.iter_content(chunk_size=4096): # Can be adjusted
                if not chunk:
                    continue
                
                mp3_buffer.extend(chunk)
                
                try:
                    # Attempt to decode the entire current mp3_buffer
                    # We expect SIGNED16 output, which matches pyaudio.paInt16
                    decoded_result = miniaudio.decode(
                        bytes(mp3_buffer), # Decode the whole buffer so far
                        output_format=miniaudio.SampleFormat.SIGNED16
                    )
                    
                    # decoded_result.samples is a flat memoryview of interleaved PCM samples
                    all_decoded_pcm_samples = decoded_result.samples
                    num_total_decoded_samples = len(all_decoded_pcm_samples)

                    if not audio_stream: # First successful decode
                        sample_rate = decoded_result.sample_rate
                        nchannels = decoded_result.nchannels
                        
                        # Determine PyAudio format from miniaudio's sample_width
                        # miniaudio.SampleFormat.SIGNED16 implies sample_width of 2
                        pyaudio_format = self.p.get_format_from_width(decoded_result.sample_width)
                        bytes_per_sample = decoded_result.sample_width # Should be 2 for SIGNED16

                        self.logger.put({
                            "text": f"音频参数: SR={sample_rate}, Channels={nchannels}, Format={pyaudio_format}, BytesPerSample={bytes_per_sample}",
                            "level": "debug"
                        })

                        audio_stream = self.p.open(
                            format=pyaudio_format,
                            channels=nchannels,
                            rate=sample_rate,
                            output=True,
                            output_device_index=self.deviceindex,
                            frames_per_buffer=2048 # PyAudio internal buffer
                        )
                    
                    # Only play the samples that are new since the last write
                    if num_total_decoded_samples > total_pcm_samples_forwarded:
                        # samples_to_play_now is a memoryview slice
                        samples_to_play_now_mv = all_decoded_pcm_samples[total_pcm_samples_forwarded:]
                        
                        # Convert the memoryview slice to bytes for PyAudio
                        audio_stream.write(samples_to_play_now_mv.tobytes())
                        
                        # Update the count of forwarded samples
                        total_pcm_samples_forwarded = num_total_decoded_samples
                                
                except miniaudio.DecodeError:
                    # Not enough data in mp3_buffer to form a complete decodable unit yet,
                    # or the stream is malformed at this point.
                    # Continue accumulating data.
                    self.logger.put({"text": "miniaudio.DecodeError: 数据不足或格式问题，继续缓冲...", "level": "trace"}) # Use trace or debug
                    continue
                except Exception as e_decode:
                    self.logger.put({"text": f"解码或播放时发生错误: {e_decode}", "level": "error"})
                    # Decide if we should break or try to continue
                    break # For now, break on other errors

            # After the loop, there's no explicit "finalize" for miniaudio.decode().
            # The last successful decode should have processed all valid data from mp3_buffer.
            # If the loop ended and mp3_buffer still had data that caused DecodeError on the last attempt,
            # that partial data might be lost with this approach.
        except Exception as e:
            self.logger.put({"text": f"流式播放异常: {str(e)}", "level": "error"})
        finally:
            if audio_stream:
                audio_stream.stop_stream()
                audio_stream.close()
            self.logger.put({"text": "TTS流式播放完成", "level": "debug"})



