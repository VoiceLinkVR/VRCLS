# 语音包参考https://learn.microsoft.com/zh-cn/azure/ai-services/speech-service/language-support?tabs=tts

whisper_voice_mapping = {
    'af': 'af-ZA-AdriNeural3',
    'am': 'am-ET-MekdesNeural3',
    'ar': 'ar-SA-ZariyahNeural',
    'as': 'as-IN-YashicaNeural3',
    'az': 'az-AZ-BanuNeural3',
    'bg': 'bg-BG-KalinaNeural',
    'bn': 'bn-IN-TanishaaNeural3',
    'bs': 'bs-BA-VesnaNeural3',
    'ca': 'ca-ES-JoanaNeural',
    'cs': 'cs-CZ-VlastaNeural',
    'cy': 'cy-GB-NiaNeural3',
    'da': 'da-DK-ChristelNeural',
    'de': 'de-DE-KatjaNeural',
    'el': 'el-GR-AthinaNeural',
    'en': 'en-US-JennyNeural',
    'es': 'es-ES-ElviraNeural',
    'et': 'et-EE-AnuNeural3',
    'eu': 'eu-ES-AinhoaNeural3',
    'fa': 'fa-IR-DilaraNeural3',
    'fi': 'fi-FI-SelmaNeural',
    'fr': 'fr-FR-DeniseNeural',
    'gl': 'gl-ES-SabelaNeural3',
    'gu': 'gu-IN-DhwaniNeural',
    'he': 'he-IL-HilaNeural',
    'hi': 'hi-IN-AnanyaNeural',
    'hr': 'hr-HR-GabrijelaNeural',
    'hu': 'hu-HU-NoemiNeural',
    'hy': 'hy-AM-AnahitNeural3',
    'id': 'id-ID-GadisNeural',
    'is': 'is-IS-GudrunNeural3',
    'it': 'it-IT-ElsaNeural',
    'ja': 'ja-JP-NanamiNeural',
    'ka': 'ka-GE-EkaNeural3',
    'kn': 'kn-IN-SapnaNeural3',
    'ko': 'ko-KR-SunHiNeural',
    'lt': 'lt-LT-OnaNeural3',
    'lv': 'lv-LV-EveritaNeural3',
    'mk': 'mk-MK-MarijaNeural3',
    'ml': 'ml-IN-SobhanaNeural3',
    'mr': 'mr-IN-AarohiNeural',
    'ms': 'ms-MY-YasminNeural',
    'mt': 'mt-MT-GraceNeural3',
    'my': 'my-MM-NilarNeural3',
    'ne': 'ne-NP-HemkalaNeural3',
    'nl': 'nl-NL-FennaNeural',
    'pa': 'pa-IN-VaaniNeural3',
    'pl': 'pl-PL-AgnieszkaNeural',
    'ps': 'ps-AF-LatifaNeural3',
    'pt': 'pt-PT-RaquelNeural',
    'ro': 'ro-RO-AlinaNeural',
    'ru': 'ru-RU-SvetlanaNeural',
    'si': 'si-LK-ThiliniNeural3',
    'sk': 'sk-SK-ViktoriaNeural',
    'sl': 'sl-SI-PetraNeural',
    'so': 'so-SO-UbaxNeural3',
    'sq': 'sq-AL-AnilaNeural3',
    'sr': 'sr-Latn-RS-SophieNeural3',
    'su': 'su-ID-TutiNeural3',
    'sv': 'sv-SE-SofieNeural',
    'sw': 'sw-KE-ZuriNeural3',
    'ta': 'ta-IN-PallaviNeural',
    'te': 'te-IN-ShrutiNeural',
    'th': 'th-TH-PremwadeeNeural',
    'tr': 'tr-TR-EmelNeural',
    'uk': 'uk-UA-PolinaNeural',
    'ur': 'ur-PK-UzmaNeural',
    'vi': 'vi-VN-HoaiMyNeural',
    'yue': 'yue-CN-XiaoMinNeural3',
    'zh': 'zh-CN-XiaoxiaoNeural',
    'zt': 'zh-TW-HsiaoChenNeural'
}

libretranslate_voice_mapping = {
    'ar': 'ar-SA-ZariyahNeural',
    'az': 'az-AZ-BanuNeural3',
    'bg': 'bg-BG-KalinaNeural',
    'bn': 'bn-IN-TanishaaNeural3',
    'ca': 'ca-ES-JoanaNeural',
    'cs': 'cs-CZ-VlastaNeural',
    'da': 'da-DK-ChristelNeural',
    'de': 'de-DE-KatjaNeural',
    'el': 'el-GR-AthinaNeural',
    'en': 'en-US-JennyNeural',
    'es': 'es-ES-ElviraNeural',
    'et': 'et-EE-AnuNeural3',
    'eu': 'eu-ES-AinhoaNeural3',
    'fa': 'fa-IR-DilaraNeural3',
    'fi': 'fi-FI-SelmaNeural',
    'fr': 'fr-FR-DeniseNeural',
    'ga': 'ga-IE-OrlaNeural3',
    'gl': 'gl-ES-SabelaNeural3',
    'he': 'he-IL-HilaNeural',
    'hi': 'hi-IN-AnanyaNeural',
    'hu': 'hu-HU-NoemiNeural',
    'id': 'id-ID-GadisNeural',
    'it': 'it-IT-ElsaNeural',
    'ja': 'ja-JP-NanamiNeural',
    'ko': 'ko-KR-SunHiNeural',
    'lt': 'lt-LT-OnaNeural3',
    'lv': 'lv-LV-EveritaNeural3',
    'ms': 'ms-MY-YasminNeural',
    'nl': 'nl-NL-FennaNeural',
    'pl': 'pl-PL-AgnieszkaNeural',
    'pt': 'pt-PT-RaquelNeural',
    'ro': 'ro-RO-AlinaNeural',
    'ru': 'ru-RU-SvetlanaNeural',
    'sk': 'sk-SK-ViktoriaNeural',
    'sl': 'sl-SI-PetraNeural',
    'sq': 'sq-AL-AnilaNeural3',
    'sr': 'sr-Latn-RS-SophieNeural3',
    'sv': 'sv-SE-SofieNeural',
    'th': 'th-TH-PremwadeeNeural',
    'tl': 'fil-PH-BlessicaNeural3',
    'tr': 'tr-TR-EmelNeural',
    'uk': 'uk-UA-PolinaNeural',
    'ur': 'ur-PK-UzmaNeural',
    'vi': 'vi-VN-HoaiMyNeural',
    'zh': 'zh-CN-XiaoxiaoNeural',
    'zt': 'yue-CN-YunSongNeural',
    'wuu': 'zh-CN-YunzeNeural'
}

import requests
import pyaudio
import miniaudio
class TTSHandler:
    def __init__(self,logger,params,mode,header,outputList,ttsVoice):
        self.baseurl=params["config"].get('baseurl')
        self.sourceType='whisper'if mode!='mic' else'libre'
        self.header=header
        self.logger=logger
        self.ttsVoice=ttsVoice
        if params["config"].get("TTSOutputName")== "" or params["config"].get("TTSOutputName") is None or params["config"].get("TTSOutputName")== "default":
            logger.put({"text":"使用系统默认输出","level":"info"})
            self.deviceindex=None
        else:
            try:
                self.deviceindex=outputList.index(params["config"].get("TTSOutputName"))
            except ValueError:
                logger.put({"text":"无法找到指定输出，使用系统默认麦克风","level":"info"})
                self.deviceindex=None
        self.p=pyaudio.PyAudio()            # 初始化 PyAudio 实例
    def __delattr__(self, name):
        self.p.terminate()
    def tts_audio(self, text, language='zh'):
        # TODO 增加按键切换开关
        self.logger.put({"text": f"{self.baseurl}/func/tts", "level": "debug"})

        try:
            response = requests.post(
                self.baseurl + '/func/tts',
                json={
                    "input": text,
                    "voice": self.ttsVoice['libretranslate_voice_mapping'][language] if self.sourceType == 'libre' else self.ttsVoice['whisper_voice_mapping'][language],
                    "speed": 1.2
                },
                headers=self.header,
                stream=True
            )

            # 先检查响应状态码
            if response.status_code != 200:
                if response.status_code == 430:
                    res = response.json()
                    self.logger.put({"text": f"TTS请求过于频繁,触发规则{res.get('limit')}", "level": "warning"})
                else:
                    self.logger.put({"text": f"TTS数据接收异常:{response.text}", "level": "warning"})
                return
            self.logger.put({"text": f"TTS文本生成: {text}", "level": "debug"})



            stream = None
            decoder = None

            # 创建字节缓冲区
            mp3_buffer = bytearray()

            # 逐块接收并解码 MP3 数据
            for chunk in response.iter_content(chunk_size=8192):
                if chunk:
                    mp3_buffer.extend(chunk)
                    
                    # 尝试解码缓冲区中的 MP3 数据
                    if not decoder:
                        try:
                            # 初始化解码器（需要至少包含 MP3 文件头的数据）
                            decoder = miniaudio.decode(
                                bytes(mp3_buffer),
                                output_format=miniaudio.SampleFormat.SIGNED16
                            )
                            # 清空缓冲区（已处理数据）
                            mp3_buffer = bytearray()
                            # 获取音频参数
                            sample_rate = decoder.sample_rate
                            nchannels = decoder.nchannels
                            
                            # 初始化音频输出流
                            stream = self.p.open(
                                format=pyaudio.paInt16,
                                channels=nchannels,
                                rate=sample_rate,
                                output=True,
                                output_device_index=self.deviceindex
                            )
                            # 播放已解码的第一块数据
                            stream.write(decoder.samples.tobytes())
                        except miniaudio.DecodeError:
                            # 缓冲区数据不足，继续接收
                            continue
                    else:
                        # 继续解码后续数据块
                        try:
                            decoded = miniaudio.decode(
                                bytes(mp3_buffer),
                                output_format=miniaudio.SampleFormat.SIGNED16
                            )
                            mp3_buffer = bytearray()
                            stream.write(decoded.samples.tobytes())
                            
                        except miniaudio.DecodeError:
                            continue

            # 处理剩余未解码数据
            if decoder and mp3_buffer:
                try:
                    decoded = miniaudio.decode(
                        bytes(mp3_buffer),
                        output_format=miniaudio.SampleFormat.SIGNED16
                    )
                    stream.write(decoded.samples.tobytes())
                except miniaudio.DecodeError:
                    pass

        except Exception as e:
            self.logger.put({"text": f"流式播放异常: {str(e)}", "level": "error"})
        finally:
            if stream:
                stream.stop_stream()
                stream.close()
            self.logger.put({"text": "TTS流式播放完成", "level": "debug"})



